#summary A quick reference for Cofoja

=Syntax=

The following page describes the syntax of contracts.

There are two forms to write contracts. Use the "Simple form" if you only need to specify one expression in an annotation, use the "Multi-clause form" if you need to specify more than one expression in an annotation.

==Simple form==

{{{
@ContractAnnotation("expression")
ContractedDeclaration
...
}}}

==Multi-clause form==

{{{
@ContractAnnotation({
  "expression1",
  "expression2",
  ...
})
ContractedDeclaration
...
}}}

==Precondition==
{{{
@Requires("expression")
ContractedDeclaration
...
}}}

==Postcondition==
{{{
@Requires("expression")
ContractedDeclaration
...
}}}

In postconditions refer to the previous state of an expression via {{{old(expression)}}}.


==Exceptional postcondition==
{{{
@ThrowEnsures({
  "ExceptionType1", "expression1",
  "ExceptionType2", "expression2",
  ...
})
ContractedDeclaration
...
}}}

==Exceptional postcondition==
{{{
@ThrowEnsures({
  "ExceptionType1", "expression1",
  "ExceptionType2", "expression2",
  ...
})
ContractedDeclaration
...
}}}

==Example==
{{{
import com.google.java.contract.*;

@Invariant({
  "class invariant 1",
  "class invariant 2"
})
class MyClass {
  @Requires("method precondition")
  @Ensures("method postcondition")
  SomeType someMethod(...) {
    ...
  }

  @Requires({
    "multi-clause",
    "precondition"
  })
  @ThrowEnsures({ "SomeException", "exceptional postcondition" })
  AnotherType anotherMethod(...) {
    ...
  }
}
}}}


=Contract annotations=

|| *Contract type* || *Annotation* (`com.google.java.contract.*`) || *Checked on* || *Inheritance* ||
|| Invariants || `Invariant` || Entry and exit of normal public and package-private methods; exit of constructors. || _and_-ed ||
|| Preconditions || `Requires` || Entry of method || _or_-ed ||
|| Postconditions || `Ensures` || Normal exit of method || _and_ed ||
|| Exceptional postconditions || `ThrowEnsures` || Abnormal termination of method (when an exception has been thrown) || _and_-ed ||

In addition to the above annotations, `Contracted` is also recognized. Classes that inherit contracts without specifying any contracts themselves directly need to be marked with this annotation for the contract compiler to see them. This is a limitation of the way annotation processing is done.


==Contract compilation (annotation processor)==

Simple case:
{{{
$ javac -processor com.google.java.contract.core.apt.AnnotationProcessor YourClass.java
}}}

All relevant `javac` flags:

|| *Flag* || *Effect* ||
|| `-Acom.google.java.contract.debug` || Enables compilation of run-time contract checking. `-g:contracts` is only available to `jassc`. ||
|| `-Acom.google.java.contract.dump[=$DUMP_DIRECTORY]` || Dumps the generated Java source of contract implementation files into `$DUMP_DIRECTORY` (defaults to `contracts_for_java.out`). ||
|| `-proc:only` || Generates contract (`.contracts`) and helper (`$com$google$java$contract$H.class`) class files only. ||

==Contract checking (Java agent)==

Simple case:
{{{
$ java -javaagent:path/to/agent.jar YourMainClass
}}}

All relevant JVM system properties:

|| *Property* || *Type* || *Effect* ||
|| `com.google.java.contract.configurator=ConfiguratorClass` || String (class name) || Calls `configure(ContractEnvironment)` on a new instance of `ConfiguratorClass` before instrumentation. `ConfiguratorClass` must be a class name suitable for `Class.forName(String)`. ||
|| `com.google.java.contract.dump=$DUMP_DIRECTORY` || String || Dumps instrumented class files into `$DUMP_DIRECTORY` ||
|| `com.google.java.contract.log.contract=true` || Boolean || Prints a trace of evaluated contracts to standard error. The contracts need to have been compiled with `-Acom.google.java.contract.debug` ||